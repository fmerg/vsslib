# `vsslib.key`

## Generalities

### Key generation

```js
import { generateKey } from 'vsslib';

const { privateKey, publicKey, ctx } = await generateKey('ed25519');
```

```js
const publicKey = await privateKey.publicKey();
```

## Verifiable identity (Schnorr Identification)

```js
const proof = await privateKey.proveIdentity({
  algorithm: Algorithms.SHA256,
});
```

```js
await publicKey.verifyIdentity(proof);
```

## Encryption

### ElGamal schemes

#### IES-Encryption (Integrated Encryption Scheme)

```js
const message = Uint8Array.from(Buffer.from('destroy earth'));
```

```js
const { ciphertext, randomness, decryptor } = await publicKey.encrypt(message, {
  scheme: ElgamalSchemes.IES,
  algorithm: Algorithms.SHA256,
  mode: AesModes.AES_256_CBC,
});
```

#### KEM-Encryption (Key Encapsulation Mechanism)

```js
const message = Uint8Array.from(Buffer.from('destroy earth'));
```

```js
const { ciphertext, randomness, decryptor } = await publicKey.encrypt(message, {
  scheme: ElgamalSchemes.KEM,
  mode: AesModes.AES_256_CBC,
});
```

#### Plain Encryption

```js
const message = (await ctx.randomPoint()).toBytes();
```

```js
const { ciphertext, randomness, decryptor } = await publicKey.encrypt(message, {
  scheme: ElgamalSchemes.PLAIN,
});
```

### Decryption

### Verifiable encryption

```js
const proof = await publicKey.proveEncryption(ciphertext, randomness, {
  algorithm: Algorithms.SHA256,
});
```

```js
await privateKey.verifyEncryption(ciphertext, proof, {
  algorithm: Algorithms.SHA256,
});
```

### Verifiable decryptors

```js
const proof = await privateKey.proveDecryptor(ciphertext, decryptor, {
  algorithm: Algorithms.SHA256,
});
```

```js
await publicKey.verifyDecryptor(ciphertext, decryptor, proof, {
  algorithm: Algorithms.SHA256,
});
```

#### Standalone decryptor generation

```js
const { decryptor, proof } = await privateKey.generateDecryptor(ciphertext, {
  algorithm: Algorithms.SHA256,
});
```

```js
await publicKey.verifyDecryptor(ciphertext, decryptor, proof, {
  algorithm: Algorithms.SHA256,
});
```

## Signatures

```js
const message = Uint8Array.from(Buffer.from('destroy earth'));

const signature = await privateKey.sign(message, {
  scheme: SignatureSchemes.SCHNORR,
  algorithm: Algorithms.SHA256,
});
```

```js
await publicKey.verifySignature(message, signature, {
  scheme: SignatureSchemes.SCHNORR,
  algorithm: Algorithms.SHA256,
});
```

## Signcryption


(1) Only Bob can read the message (data confidentiality)
(2) Bob is convinced that the message came from Alice (sender authentication)
(3) Data integrity

security =
1. ciphertext integrity (The other game captures data au-
thenticity: an adversary who does not have Alice’s or Bob’s secret key cannot
make Bob accept a ciphertext that was not generated by Alice with the intent of sending it to
Bob.)
2. CCA security (an adversary who does not have Alice’s or Bob’s secret key
cannot break semantic security for a set of challenge ciphertexts from Alice to Bob.)

- replay attack: Signcryption is not designed to prevent replay attacks. Higher level protocols
that use sign-cryption must themselves take measures to counter-act them.

- Adaptive vs static: For
most realistic schemes (including all of those discussed here), this
distinction makes no difference,
but it is possible to dream up contrived schemes where it does (see Exercise
13.18). We have
presented the definition with statically chosen IDs mainly for the sake of
simplicity (and because,
arguably, honest users choose their IDs in a manner that is not so much under
an adversary’s
control).

- EtS: secure assuming E is CCA-secure with associated data and S is *strongly*
  secure
- StE: secure assuming E is CCA-secure with associated data and S is secure


- (Sender corruption) Forward secrecy: The goal is to ensure that CCA security is maintained even
  if the adversary obtains the sender’s secret key. Suppose Alice encrypts
a message to Bob and sends the resulting ciphertext c to Bob. A week later
the adversary corrupts Alice and steals her secret key. Bob’s key remains
intact and only known to Bob. One might reasonably expect that the adversary
should not be able to decrypt c using Alice’s secret key.


- EtS: forward secure under special assumptions(
unique signatures, i.e., for every public key and message, there is at most one
valid signature — full domain hash is such a scheme).
- StE: forward secure

https://theworld.com/~dtd/sign_encrypt/sign_encrypt7.html

```js
const { privateKey: senderPrivate, publicKey: senderPublic } = await generateKey('ed25519');
```

```js
const { privateKey: receiverPrivate, publicKey: receiverPublic } = await generateKey('ed25519');
```

```js
const message = Uint8Array.from(Buffer.from('destroy earth'));

const { ciphertext, signature } = await senderPrivate.signEncrypt(message, receiverPublic, {
  encScheme: ElgamalSchemes.IES,
  sigScheme: SignatureSchemes.SCHNORR,
  algorithm: Algorithms.SHA256
});
```

```js
const { plaintext } = await receiverPrivate.verifyDecrypt(ciphertext, signature, senderPublic, {
  encScheme: ElgamalSchemes.IES,
  sigScheme: SignatureSchemes.SCHNORR,
  algorithm: Algorithms.SHA256
});
```
